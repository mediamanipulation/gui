App Content Summary
Generated on: 2025-06-08 09:53:01
Total Files: 42



================================================================================
FILE: gui\__init__.py
================================================================================



================================================================================
FILE: gui\app copy.py
================================================================================

# gui/app.py

import tkinter as tk
from tkinter import ttk, filedialog, messagebox
import pandas as pd
import json
import os

class ExcelTransformerApp:
    def __init__(self, root):
        self.root = root
        self.root.title("Excel Transformer Pro")

        self.df = None
        self.ref_df = None
        self.file_path = None
        self.config_path = "config.json"
        self.presets_path = "presets.json"
        self.header_row = tk.IntVar(value=0)

        self.column_vars = {}
        self.formula_vars = {}
        self.preview_labels = {}

        # === Layout: Main Excel File Controls ===
        file_frame = ttk.LabelFrame(root, text="Main Excel File")
        file_frame.pack(padx=10, pady=5, fill="x")

        tk.Button(file_frame, text="Load Main Excel File", command=self.load_main_file).pack(side="left", padx=5, pady=5)
        tk.Label(file_frame, text="Header Row:").pack(side="left")
        tk.Entry(file_frame, textvariable=self.header_row, width=5).pack(side="left", padx=5)

        self.sheet_dropdown = ttk.Combobox(file_frame, state="readonly")
        self.sheet_dropdown.pack(side="left", padx=5)
        self.sheet_dropdown.bind("<<ComboboxSelected>>", self.load_sheet)

        # === Layout: Preset Selector ===
        preset_frame = ttk.LabelFrame(root, text="Column Presets")
        preset_frame.pack(padx=10, pady=5, fill="x")

        self.preset_var = tk.StringVar()
        self.preset_dropdown = ttk.Combobox(preset_frame, state="readonly", textvariable=self.preset_var)
        self.preset_dropdown.pack(side="left", padx=5)
        tk.Button(preset_frame, text="Apply Preset", command=self.apply_preset).pack(side="left", padx=5)
        self.load_presets()

        # === Layout: Column and Formula Editor ===
        self.columns_frame = ttk.LabelFrame(root, text="Column Selection and Formulas")
        self.columns_frame.pack(padx=10, pady=5, fill="both", expand=True)

        # === Layout: Reference Join ===
        join_frame = ttk.LabelFrame(root, text="Reference File Join")
        join_frame.pack(padx=10, pady=5, fill="x")

        tk.Button(join_frame, text="Load Reference File", command=self.load_reference_file).grid(row=0, column=0, padx=5, pady=5)

        tk.Label(join_frame, text="Main Key:").grid(row=0, column=1)
        self.main_key_entry = tk.Entry(join_frame)
        self.main_key_entry.grid(row=0, column=2)

        tk.Label(join_frame, text="Ref Key:").grid(row=0, column=3)
        self.ref_key_entry = tk.Entry(join_frame)
        self.ref_key_entry.grid(row=0, column=4)

        tk.Label(join_frame, text="Ref Columns:").grid(row=0, column=5)
        self.ref_cols_entry = tk.Entry(join_frame)
        self.ref_cols_entry.grid(row=0, column=6)

        # === Layout: Config + Export ===
        config_frame = ttk.LabelFrame(root, text="Save/Load + Export")
        config_frame.pack(padx=10, pady=10, fill="x")

        tk.Button(config_frame, text="Save Config", command=self.save_config).pack(side="left", padx=5)
        tk.Button(config_frame, text="Load Config", command=self.load_config).pack(side="left", padx=5)
        tk.Button(config_frame, text="Export", command=self.export).pack(side="right", padx=5)

    def load_main_file(self):
        path = filedialog.askopenfilename(filetypes=[("Excel files", "*.xlsx *.xls")])
        if not path:
            return
        self.file_path = path
        xls = pd.ExcelFile(self.file_path)
        self.sheet_dropdown["values"] = xls.sheet_names
        self.sheet_dropdown.current(0)
        self.load_sheet()

    def load_sheet(self, *args):
        sheet = self.sheet_dropdown.get()
        if not sheet:
            return
        df = pd.read_excel(self.file_path, sheet_name=sheet, header=self.header_row.get())
        self.df = df
        self.column_vars.clear()
        self.formula_vars.clear()
        self.preview_labels.clear()
        for widget in self.columns_frame.winfo_children():
            widget.destroy()

        for i, col in enumerate(df.columns):
            row_frame = tk.Frame(self.columns_frame)
            row_frame.pack(anchor="w", pady=2, padx=5)

            var = tk.BooleanVar()
            chk = tk.Checkbutton(row_frame, text=col, variable=var)
            chk.grid(row=0, column=0, sticky="w")
            self.column_vars[col] = var

            formula_var = tk.StringVar()
            entry = tk.Entry(row_frame, textvariable=formula_var, width=35)
            entry.grid(row=0, column=1, padx=5)
            entry.bind("<KeyRelease>", lambda e, c=col: self.update_formula_preview(c))
            self.formula_vars[col] = formula_var

            preview_label = tk.Label(row_frame, text="", font=("Courier", 9), fg="gray")
            preview_label.grid(row=1, column=1, sticky="w")
            self.preview_labels[col] = preview_label

    def update_formula_preview(self, col):
        if self.df is None or col not in self.formula_vars:
            return
        formula = self.formula_vars[col].get().strip()
        if not formula:
            self.preview_labels[col].config(text="")
            return
        try:
            preview = self.df.eval(formula).dropna().iloc[0]
            self.preview_labels[col].config(text=f"Preview: {preview}")
        except Exception as e:
            self.preview_labels[col].config(text=f"Error")

    def load_presets(self):
        if os.path.exists(self.presets_path):
            with open(self.presets_path, "r") as f:
                self.presets = json.load(f)
            self.preset_dropdown["values"] = list(self.presets.keys())

    def apply_preset(self):
        preset_name = self.preset_var.get()
        if preset_name not in self.presets:
            return
        preset = self.presets[preset_name]
        columns = preset.get("columns", [])
        formulas = preset.get("formulas", {})

        for col, var in self.column_vars.items():
            var.set(col in columns)
        for col, val in formulas.items():
            if col in self.formula_vars:
                self.formula_vars[col].set(val)
                self.update_formula_preview(col)

    def load_reference_file(self):
        path = filedialog.askopenfilename(filetypes=[("Excel files", "*.xlsx *.xls")])
        if path:
            self.ref_df = pd.read_excel(path)

    def export(self):
        selected_cols = [col for col, var in self.column_vars.items() if var.get()]
        if not selected_cols:
            messagebox.showwarning("No columns selected", "Select at least one column.")
            return
        result = pd.DataFrame()
        for col in selected_cols:
            formula = self.formula_vars[col].get().strip()
            if formula:
                try:
                    result[col] = self.df.eval(formula)
                except Exception as e:
                    result[col] = f"#ERR {e}"
            else:
                result[col] = self.df[col]

        if self.ref_df is not None:
            main_key = self.main_key_entry.get().strip()
            ref_key = self.ref_key_entry.get().strip()
            ref_cols = [c.strip() for c in self.ref_cols_entry.get().split(',') if c.strip()]
            if main_key and ref_key and ref_cols:
                ref_slice = self.ref_df[[ref_key] + ref_cols]
                result = result.merge(ref_slice, left_on=main_key, right_on=ref_key, how="left")

        out_path = filedialog.asksaveasfilename(defaultextension=".xlsx")
        if out_path:
            result.to_excel(out_path, index=False)
            messagebox.showinfo("Done", f"Saved to {out_path}")

    def save_config(self):
        config = {
            "selected": [col for col, var in self.column_vars.items() if var.get()],
            "formulas": {col: var.get() for col, var in self.formula_vars.items()},
            "header_row": self.header_row.get()
        }
        with open(self.config_path, "w") as f:
            json.dump(config, f)
        messagebox.showinfo("Saved", f"Config saved to {self.config_path}")

    def load_config(self):
        try:
            with open(self.config_path, "r") as f:
                config = json.load(f)
            self.header_row.set(config.get("header_row", 0))
            for col in config.get("selected", []):
                if col in self.column_vars:
                    self.column_vars[col].set(True)
            for col, formula in config.get("formulas", {}).items():
                if col in self.formula_vars:
                    self.formula_vars[col].set(formula)
                    self.update_formula_preview(col)
            messagebox.showinfo("Loaded", "Config loaded.")
        except Exception as e:
            messagebox.showerror("Error", f"Could not load config: {e}")


================================================================================
FILE: gui\app.py
================================================================================

# gui/app.py
import os
import json
import tkinter as tk
from tkinter import filedialog, messagebox

import pandas as pd

from gui.ui.layout import build_layout
from gui.core.presets import load_presets, apply_preset
from gui.core.formula_engine import evaluate_formula
from gui.core.exporter import export_to_excel

# alias imported helpers to avoid name-clash with our class methods
from gui.core.config_manager import (
    save_config as cfg_save,
    load_config as cfg_load,
    list_recent,
)


class ExcelTransformerApp:
    """Main Tkinter GUI application."""

    # ------------------------------------------------------------------ #
    # Initialisation                                                     #
    # ------------------------------------------------------------------ #
    def __init__(self, root: tk.Tk):
        self.root = root
        self.root.title("Matrix Exporter")

        # state
        self.df = None
        self.ref_df = None
        self.file_path = None
        self.header_row = tk.IntVar(value=0)

        # UI‐bound dicts
        self.column_vars: dict[str, tk.BooleanVar] = {}
        self.formula_vars: dict[str, tk.StringVar] = {}
        self.preview_labels: dict[str, tk.Label] = {}

        # presets + recent configs
        self.presets_path = "presets.json"
        self.presets = load_presets(self.presets_path)
        self.recent_configs = list_recent()

        # build GUI
        build_layout(self)

    # ------------------------------------------------------------------ #
    # File + sheet handling                                              #
    # ------------------------------------------------------------------ #
    def load_main_file(self) -> None:
        path = filedialog.askopenfilename(filetypes=[("Excel files", "*.xlsx *.xls")])
        if not path:
            return
        self.file_path = path
        xls = pd.ExcelFile(path)
        self.sheet_dropdown.configure(values=xls.sheet_names)
        self.sheet_dropdown.current(0)
        self.load_sheet()

    def load_sheet(self, *_):
        sheet_name = self.sheet_dropdown.get()
        self.df = pd.read_excel(
            self.file_path,
            sheet_name=sheet_name,
            header=self.header_row.get(),
        )

        # clear old widgets/vars
        self.column_vars.clear()
        self.formula_vars.clear()
        self.preview_labels.clear()
        for widget in self.columns_frame.winfo_children():
            widget.destroy()

        # rebuild
        for col in self.df.columns:
            self.add_column_row(col)

    # ------------------------------------------------------------------ #
    # Dynamic column-row creation                                        #
    # ------------------------------------------------------------------ #
    def add_column_row(self, col: str) -> None:
        row = tk.Frame(self.columns_frame)
        row.pack(anchor="w", pady=1, padx=5, fill="x")

        var = tk.BooleanVar()
        tk.Checkbutton(row, text=col, variable=var).grid(row=0, column=0, sticky="w")
        self.column_vars[col] = var

        f_var = tk.StringVar()
        entry = tk.Entry(row, textvariable=f_var, width=35)
        entry.grid(row=0, column=1, padx=4, sticky="ew")
        entry.bind("<KeyRelease>", lambda _e, c=col: self.update_formula_preview(c))
        self.formula_vars[col] = f_var

        preview = tk.Label(row, text="", font=("Consolas", 9), fg="gray")
        preview.grid(row=1, column=1, sticky="w")
        self.preview_labels[col] = preview

        row.grid_columnconfigure(1, weight=1)

    # ------------------------------------------------------------------ #
    # Formula preview + presets                                          #
    # ------------------------------------------------------------------ #
    def update_formula_preview(self, col: str) -> None:
        result = evaluate_formula(self.df, col, self.formula_vars[col].get().strip())
        self.preview_labels[col].config(text=result)

    def apply_preset(self):
        apply_preset(
            self.presets,
            self.preset_var.get(),
            self.column_vars,
            self.formula_vars,
            self.update_formula_preview,
        )

    # ------------------------------------------------------------------ #
    # Reference file load / export                                       #
    # ------------------------------------------------------------------ #
    def load_reference_file(self):
        path = filedialog.askopenfilename(filetypes=[("Excel files", "*.xlsx *.xls")])
        if path:
            self.ref_df = pd.read_excel(path)

    def export(self):
        export_to_excel(
            self.df,
            self.column_vars,
            self.formula_vars,
            self.ref_df,
            self.main_key_entry.get(),
            self.ref_key_entry.get(),
            self.ref_cols_entry.get(),
            self.file_path,
        )

    # ------------------------------------------------------------------ #
    # Config save / load                                                 #
    # ------------------------------------------------------------------ #
    def save_config(self):
        cfg = {
            "selected": [c for c, v in self.column_vars.items() if v.get()],
            "formulas": {c: v.get() for c, v in self.formula_vars.items()},
            "header_row": self.header_row.get(),
        }
        path = filedialog.asksaveasfilename(
            defaultextension=".json", filetypes=[("JSON", "*.json")]
        )
        if not path:
            return
        cfg_save(cfg, path)
        self._refresh_recent_configs()
        messagebox.showinfo("Saved", f"Config saved:\n{path}")

    def load_config(self):
        path = filedialog.askopenfilename(
            defaultextension=".json", filetypes=[("JSON", "*.json")]
        )
        if not path:
            return
        try:
            cfg = cfg_load(path)
            self._apply_loaded_config(cfg)
            self._refresh_recent_configs()
            messagebox.showinfo("Loaded", f"Config loaded:\n{path}")
        except Exception as exc:
            messagebox.showerror("Error", f"Could not load config:\n{exc}")

    # ------------------------------------------------------------------ #
    # Helpers                                                            #
    # ------------------------------------------------------------------ #
    def _apply_loaded_config(self, cfg: dict):
        """Apply a config dict to all UI elements."""
        self.header_row.set(cfg.get("header_row", 0))

        selected = set(cfg.get("selected", []))
        for col in self.column_vars:
            self.column_vars[col].set(col in selected)

        for col, formula in cfg.get("formulas", {}).items():
            if col in self.formula_vars:
                self.formula_vars[col].set(formula)
                self.update_formula_preview(col)

    def _refresh_recent_configs(self):
        """Refresh the MRU dropdown after save/load."""
        self.recent_configs = list_recent()
        if hasattr(self, "recent_combo"):
            self.recent_combo.configure(values=self.recent_configs)


================================================================================
FILE: gui\confluence\settings.py
================================================================================

# gui/confluence/settings.py
import os
import json
from cryptography.fernet import Fernet

SETTINGS_FILE = "app_settings.json"
KEY_FILE = "key.key"


def generate_key():
    key = Fernet.generate_key()
    with open(KEY_FILE, "wb") as f:
        f.write(key)
    return key


def load_key():
    if not os.path.exists(KEY_FILE):
        return generate_key()
    with open(KEY_FILE, "rb") as f:
        return f.read()


def encrypt_token(token: str) -> str:
    key = load_key()
    fernet = Fernet(key)
    return fernet.encrypt(token.encode()).decode()


def decrypt_token(token_enc: str) -> str:
    key = load_key()
    fernet = Fernet(key)
    return fernet.decrypt(token_enc.encode()).decode()


def save_confluence_settings(base_url: str, token: str):
    settings = load_settings()
    settings["confluence"] = {
        "base_url": base_url,
        "token": encrypt_token(token)
    }
    with open(SETTINGS_FILE, "w") as f:
        json.dump(settings, f, indent=2)


def load_confluence_settings():
    settings = load_settings()
    if "confluence" in settings:
        conf = settings["confluence"]
        return {
            "base_url": conf["base_url"],
            "token": decrypt_token(conf["token"])
        }
    return None


def load_settings():
    if os.path.exists(SETTINGS_FILE):
        with open(SETTINGS_FILE, "r") as f:
            return json.load(f)
    return {}


================================================================================
FILE: gui\confluence\ui.py
================================================================================

# gui/confluence/ui.py
import tkinter as tk
from tkinter import ttk, messagebox
from .settings import save_confluence_settings, load_confluence_settings
from .uploader import upload_to_page
import os


def build_confluence_settings_dialog(app):
    """Open a dialog to configure Confluence settings."""
    dialog = tk.Toplevel(app.root)
    dialog.title("Confluence Settings")
    dialog.grab_set()
    dialog.resizable(False, False)

    tk.Label(dialog, text="Confluence Base URL:").grid(row=0, column=0, sticky="e", padx=5, pady=5)
    base_var = tk.StringVar()
    tk.Entry(dialog, textvariable=base_var, width=40).grid(row=0, column=1, padx=5, pady=5)

    tk.Label(dialog, text="API Token:").grid(row=1, column=0, sticky="e", padx=5, pady=5)
    token_var = tk.StringVar()
    tk.Entry(dialog, textvariable=token_var, width=40, show="*").grid(row=1, column=1, padx=5, pady=5)

    def save():
        base = base_var.get().strip()
        token = token_var.get().strip()
        if not base or not token:
            messagebox.showwarning("Input Error", "Both fields are required.")
            return
        save_confluence_settings(base, token)
        messagebox.showinfo("Saved", "Confluence settings saved.")
        dialog.destroy()

    ttk.Button(dialog, text="Save", command=save).grid(row=2, column=1, pady=10, sticky="e")


def attach_upload_button(parent_frame, app):
    """Attach a Confluence Upload button to an existing frame."""
    def upload():
        if app.file_path is None or not os.path.exists(app.file_path):
            messagebox.showwarning("Export Required", "Please export the Excel file first.")
            return

        settings = load_confluence_settings()
        if not settings:
            messagebox.showwarning("Settings Missing", "Please configure Confluence settings first.")
            build_confluence_settings_dialog(app)
            return

        def do_upload():
            page_id = app.simple_input_dialog("Confluence Page ID", "Enter Confluence Page ID:")
            if not page_id:
                return
            try:
                result = upload_to_page(app.file_path, page_id)
                messagebox.showinfo("Upload Success", f"File uploaded to page {page_id}")
            except Exception as e:
                messagebox.showerror("Upload Failed", str(e))
                
            print("[DEBUG] Attaching Upload to Confluence button")  

        app.root.after(100, do_upload)

    upload_btn = ttk.Button(parent_frame, text="Upload to Confluence", command=upload)
    upload_btn.pack(side="right", padx=5)


================================================================================
FILE: gui\confluence\uploader.py
================================================================================

# gui/confluence/uploader.py
import os
import requests
from .settings import load_confluence_settings


def upload_to_page(file_path: str, page_id: str) -> dict:
    """Uploads a file to the specified Confluence page as an attachment."""
    settings = load_confluence_settings()
    if not settings:
        raise ValueError("Confluence settings not configured")

    if not os.path.exists(file_path):
        raise FileNotFoundError(f"File not found: {file_path}")

    url = f"{settings['base_url'].rstrip('/')}/rest/api/content/{page_id}/child/attachment"
    headers = {"Authorization": f"Bearer {settings['token']}"}
    files = {
        'file': (os.path.basename(file_path), open(file_path, 'rb'),
                 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
    }

    response = requests.post(url, headers=headers, files=files)
    if not response.ok:
        raise Exception(f"Upload failed: {response.status_code} - {response.text}")
    return response.json()


================================================================================
FILE: gui\core\__init__.py
================================================================================



================================================================================
FILE: gui\core\config_manager.py
================================================================================

# core/config_manager.py
"""Read/write config JSON files anywhere and keep a small MRU list."""

import json
import os

MAX_RECENT = 8          # how many recent files to remember
SETTINGS_FILE = "app_settings.json"


def _load_settings():
    if os.path.exists(SETTINGS_FILE):
        with open(SETTINGS_FILE, "r", encoding="utf-8") as f:
            return json.load(f)
    return {}


def _save_settings(settings: dict):
    with open(SETTINGS_FILE, "w", encoding="utf-8") as f:
        json.dump(settings, f, indent=2)


def _touch_recent(path: str):
    settings = _load_settings()
    recent = settings.get("recent_configs", [])
    if path in recent:
        recent.remove(path)
    recent.insert(0, path)
    settings["recent_configs"] = recent[:MAX_RECENT]
    _save_settings(settings)


def save_config(config: dict, path: str):
    """Write JSON to *path* and add it to the MRU list."""
    with open(path, "w", encoding="utf-8") as f:
        json.dump(config, f, indent=2)
    _touch_recent(path)


def load_config(path: str) -> dict:
    """Read JSON from *path* and add it to the MRU list."""
    with open(path, "r", encoding="utf-8") as f:
        data = json.load(f)
    _touch_recent(path)
    return data


def list_recent() -> list[str]:
    """Return most-recent-used config paths (newest first)."""
    return _load_settings().get("recent_configs", [])


================================================================================
FILE: gui\core\conflunce\config.py
================================================================================

# gui/core/confluence/config.py

import os
import json
from cryptography.fernet import Fernet

SETTINGS_FILE = "app_settings.json"
KEY_FILE = "key.key"

def generate_key():
    key = Fernet.generate_key()
    with open(KEY_FILE, "wb") as f:
        f.write(key)
    return key

def load_key():
    if not os.path.exists(KEY_FILE):
        return generate_key()
    with open(KEY_FILE, "rb") as f:
        return f.read()

def encrypt_token(token: str) -> str:
    fernet = Fernet(load_key())
    return fernet.encrypt(token.encode()).decode()

def decrypt_token(token_enc: str) -> str:
    fernet = Fernet(load_key())
    return fernet.decrypt(token_enc.encode()).decode()

def save_confluence_settings(base_url: str, token: str):
    settings = load_settings()
    settings["confluence"] = {
        "base_url": base_url,
        "token": encrypt_token(token)
    }
    with open(SETTINGS_FILE, "w") as f:
        json.dump(settings, f, indent=2)

def load_settings():
    if os.path.exists(SETTINGS_FILE):
        with open(SETTINGS_FILE, "r") as f:
            return json.load(f)
    return {}

def load_confluence_settings():
    settings = load_settings()
    if "confluence" in settings:
        conf = settings["confluence"]
        return {
            "base_url": conf["base_url"],
            "token": decrypt_token(conf["token"])
        }
    return None


================================================================================
FILE: gui\core\conflunce\metadata.py
================================================================================

# gui/core/confluence/metadata.py

import pandas as pd

def generate_summary(file_path: str) -> str:
    """
    Generates an HTML summary of the Excel file's metadata (columns, row count).
    """
    try:
        df = pd.read_excel(file_path)
        cols = df.columns.tolist()
        summary = f"<p><b>Upload Summary:</b></p>"
        summary += f"<p><b>File:</b> {os.path.basename(file_path)}</p>"
        summary += f"<p><b>Rows:</b> {len(df)}</p>"
        summary += f"<p><b>Columns:</b> {', '.join(cols)}</p>"
        return summary
    except Exception as e:
        return f"<p><b>Upload Summary:</b> Failed to read file - {e}</p>"

================================================================================
FILE: gui\core\conflunce\uploader.py
================================================================================

# gui/core/confluence/uploader.py

import os
import requests
from gui.core.confluence.config import load_confluence_settings
from gui.core.confluence.metadata import generate_summary


def upload_to_confluence(file_path: str, page_id: str) -> dict:
    """
    Uploads an Excel file to a Confluence page as an attachment.
    Includes a summary comment.
    Returns Confluence response JSON.
    """
    settings = load_confluence_settings()
    if not settings:
        raise ValueError("Confluence settings not configured")

    url = f"{settings['base_url']}/rest/api/content/{page_id}/child/attachment"
    headers = {"Authorization": f"Bearer {settings['token']}", "X-Atlassian-Token": "no-check"}

    with open(file_path, "rb") as f:
        files = {
            "file": (os.path.basename(file_path), f,
                     "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")
        }
        response = requests.post(url, headers=headers, files=files)

    if not response.ok:
        raise Exception(f"Upload failed: {response.status_code} - {response.text}")

    summary_text = generate_summary(file_path)
    add_comment_to_page(settings, page_id, summary_text)
    return response.json()


def add_comment_to_page(settings, page_id: str, comment_text: str):
    """
    Posts a comment under a Confluence page.
    """
    url = f"{settings['base_url']}/rest/api/content/{page_id}/child/comment"
    headers = {
        "Authorization": f"Bearer {settings['token']}",
        "Content-Type": "application/json"
    }
    payload = {
        "type": "comment",
        "container": {"type": "page", "id": page_id},
        "body": {
            "storage": {
                "value": comment_text,
                "representation": "storage"
            }
        }
    }
    requests.post(url, headers=headers, json=payload)




================================================================================
FILE: gui\core\conflunce_manager.py
================================================================================

# confluence_manager.py
import os
import json
import requests
from cryptography.fernet import Fernet

SETTINGS_FILE = "app_settings.json"
KEY_FILE = "key.key"

# --- Encryption Helpers ---
def generate_key():
    key = Fernet.generate_key()
    with open(KEY_FILE, "wb") as f:
        f.write(key)
    return key

def load_key():
    if not os.path.exists(KEY_FILE):
        return generate_key()
    with open(KEY_FILE, "rb") as f:
        return f.read()

def encrypt_token(token: str) -> str:
    key = load_key()
    fernet = Fernet(key)
    return fernet.encrypt(token.encode()).decode()

def decrypt_token(token_enc: str) -> str:
    key = load_key()
    fernet = Fernet(key)
    return fernet.decrypt(token_enc.encode()).decode()

# --- Settings Management ---
def save_confluence_settings(base_url: str, token: str):
    settings = load_settings()
    settings["confluence"] = {
        "base_url": base_url,
        "token": encrypt_token(token)
    }
    with open(SETTINGS_FILE, "w") as f:
        json.dump(settings, f, indent=2)

def forget_confluence_settings():
    settings = load_settings()
    settings.pop("confluence", None)
    with open(SETTINGS_FILE, "w") as f:
        json.dump(settings, f, indent=2)

def load_confluence_settings():
    settings = load_settings()
    if "confluence" in settings:
        conf = settings["confluence"]
        return {
            "base_url": conf["base_url"],
            "token": decrypt_token(conf["token"])
        }
    return None

def load_settings():
    if os.path.exists(SETTINGS_FILE):
        with open(SETTINGS_FILE, "r") as f:
            return json.load(f)
    return {}

# --- File Upload ---
def upload_excel_to_confluence(file_path: str, page_id: str):
    settings = load_confluence_settings()
    if not settings:
        raise ValueError("No Confluence settings configured")

    url = f"{settings['base_url']}/rest/api/content/{page_id}/child/attachment"
    headers = {
        "Authorization": f"Bearer {settings['token']}",
    }

    files = {
        'file': (os.path.basename(file_path), open(file_path, 'rb'), 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
    }

    response = requests.post(url, headers=headers, files=files)
    if not response.ok:
        raise Exception(f"Upload failed: {response.status_code} - {response.text}")
    return response.json()


================================================================================
FILE: gui\core\exporter.py
================================================================================

import pandas as pd
from tkinter import filedialog, messagebox # Keep these for UI interaction
from asteval import Interpreter

# Create a persistent asteval interpreter instance
aeval = Interpreter()

def evaluate_with_asteval(row, formula):
    """Helper function to evaluate a formula for a row using asteval."""
    try:
        return aeval(formula, symtable=row.to_dict())
    except Exception as e:
        return f"#AERR! {e}"

def export_to_excel(df, column_vars, formula_vars, ref_df, main_key, ref_key, ref_cols_input, file_path):
    """
    Exports data to Excel, evaluating formulas using pandas.eval and asteval as fallback.
    """
    selected_cols = [col for col, var in column_vars.items() if var.get()]
    if not selected_cols:
        messagebox.showwarning("No columns selected", "Select at least one column.")
        return

    if df is None:
         messagebox.showerror("Error", "No main data loaded to export.")
         return

    result = pd.DataFrame(index=df.index)

    for col in selected_cols:
        # --- Get the formula string ---
        # Get the StringVar object if it exists for this column
        formula_var_object = formula_vars.get(col)

        # Retrieve the string value from the StringVar, default to "" if object is missing
        formula = ""
        if formula_var_object:
            formula = formula_var_object.get().strip()
        # Removed the incorrect reference to tk.StringVar here

        # --- Process based on formula presence ---
        if not formula:
            # No formula, just copy the original column if it exists
            if col in df.columns:
                result[col] = df[col]
            else:
                messagebox.showwarning("Missing Column", f"Selected column '{col}' not found in the original data and has no formula.")
                result[col] = None
            continue

        # --- Formula Evaluation (remains the same) ---
        try:
            result[col] = df.eval(formula)
        except Exception as pd_eval_err:
            try:
                result[col] = df.apply(lambda row: evaluate_with_asteval(row, formula), axis=1)
            except Exception as apply_err:
                messagebox.showerror("Apply Error", f"Failed to apply formula for column '{col}': {apply_err}")
                result[col] = f"#APPLY_ERR! {apply_err}"

    # --- Reference File Join (remains the same) ---
    if ref_df is not None:
        main_key_stripped = main_key.strip()
        ref_key_stripped = ref_key.strip()
        ref_cols = [c.strip() for c in ref_cols_input.split(',') if c.strip()]

        if main_key_stripped and ref_key_stripped and ref_cols:
            if main_key_stripped not in result.columns:
                 messagebox.showerror("Join Error", f"Main join key '{main_key_stripped}' not found in the processed data.")
                 return
            if ref_key_stripped not in ref_df.columns:
                 messagebox.showerror("Join Error", f"Reference join key '{ref_key_stripped}' not found in the reference file.")
                 return

            missing_ref_cols = [c for c in ref_cols if c not in ref_df.columns]
            if missing_ref_cols:
                 messagebox.showwarning("Join Warning", f"Reference columns not found in reference file and will be skipped: {', '.join(missing_ref_cols)}")
                 ref_cols = [c for c in ref_cols if c in ref_df.columns]

            if not ref_cols:
                 messagebox.showwarning("Join Warning", "No valid reference columns specified or found for joining.")
            else:
                try:
                    ref_slice = ref_df[[ref_key_stripped] + ref_cols].copy()
                    ref_slice = ref_slice.loc[:,~ref_slice.columns.duplicated()]
                    result = result.merge(
                        ref_slice,
                        left_on=main_key_stripped,
                        right_on=ref_key_stripped,
                        how="left"
                    )
                except Exception as e:
                    messagebox.showerror("Join Error", f"Error during merge operation: {e}")
                    return

    # --- Save Output (remains the same) ---
    out_path = filedialog.asksaveasfilename(
        defaultextension=".xlsx",
        filetypes=[("Excel files", "*.xlsx"), ("All files", "*.*")]
        )
    if out_path:
        try:
            result.to_excel(out_path, index=False)
            messagebox.showinfo("Done", f"Data successfully exported to:\n{out_path}")
        except Exception as e:
             messagebox.showerror("Export Error", f"Failed to save the Excel file:\n{e}")

================================================================================
FILE: gui\core\formula_engine.py
================================================================================

import numpy as np
import pandas as pd
from asteval import Interpreter # Import asteval

# Create a persistent asteval interpreter instance
aeval = Interpreter()

def evaluate_formula(df, col, formula):
    """
    Evaluates a formula for preview using pandas.eval and asteval as a fallback.
    """
    if not formula:
        return ""
    if df is None or df.empty:
        return "Error: No data loaded"

    try:
        # First, try pandas.eval (faster and generally safe)
        value = df.eval(formula).dropna().iloc[0]
        return f"Preview (pandas): {value}"
    except Exception as pd_eval_err:
        # If pandas.eval fails, try asteval for the first row
        try:
            # Get the first row as a dictionary for context
            first_row_dict = df.iloc[0].to_dict()

            # Evaluate using asteval, passing the row dict as symbols
            # Use a fresh interpreter or clear symtable if necessary, but
            # for previews, reusing might be okay. Be mindful of side effects
            # if formulas modify the symtable (though not typical here).
            preview = aeval(formula, symtable=first_row_dict)

            # Check if preview is NaN or None (common results of failed ops)
            if pd.isna(preview):
                 return f"Preview (asteval): NaN/None"

            return f"Preview (asteval): {preview}"
        except Exception as asteval_err:
            # Both methods failed
            # Provide a more specific error message if helpful
            # print(f"Pandas eval error: {pd_eval_err}")
            # print(f"Asteval error: {asteval_err}")
            return "Error evaluating formula"

================================================================================
FILE: gui\core\loader.py
================================================================================

import pandas as pd

def load_excel_sheet(file_path, sheet_name, header_row):
    return pd.read_excel(file_path, sheet_name=sheet_name, header=header_row)


================================================================================
FILE: gui\core\presets.py
================================================================================

import json
import os

def load_presets(path):
    if os.path.exists(path):
        with open(path, 'r') as f:
            return json.load(f)
    return {}

def apply_preset(presets, name, column_vars, formula_vars, preview_callback):
    if name not in presets:
        return
    preset = presets[name]
    columns = preset.get("columns", [])
    formulas = preset.get("formulas", {})

    for col, var in column_vars.items():
        var.set(col in columns)
    for col, val in formulas.items():
        if col in formula_vars:
            formula_vars[col].set(val)
            preview_callback(col)


================================================================================
FILE: gui\ui\components\__init__.py
================================================================================



================================================================================
FILE: gui\ui\components\column_controls_section.py
================================================================================

"""Scrollable check-box + formula editor for every column."""

import tkinter as tk
from tkinter import ttk

from gui.ui.utils import (
    PAD_X, PAD_Y, PREVIEW_COLOR, BG_COLOR, USE_ENHANCED_UI
)

# optional enhanced widget
try:
    from gui.ui.custom_widgets import FormulaEntry          # noqa: F401
except ImportError:                                         # falls back to tk.Entry
    FormulaEntry = None


def build(app):
    outer = ttk.LabelFrame(app.root, text="Column Controls")
    outer.pack(fill="both", expand=True, padx=PAD_X, pady=(0, PAD_Y))

    # ---------------- scrollable canvas -----------------
    wrapper = ttk.Frame(outer)
    wrapper.pack(fill="both", expand=True, padx=PAD_X, pady=PAD_Y)

    canvas = tk.Canvas(wrapper, borderwidth=0, highlightthickness=0, background="white")
    vbar   = ttk.Scrollbar(wrapper, orient="vertical", command=canvas.yview)
    canvas.configure(yscrollcommand=vbar.set)

    vbar.pack(side="right", fill="y")
    canvas.pack(side="left", fill="both", expand=True)

    app.columns_frame = ttk.Frame(canvas)
    canvas.create_window((0, 0), window=app.columns_frame, anchor="nw")

    def _update_region(_):            # keep scroll-region in sync
        canvas.configure(scrollregion=canvas.bbox("all"))
    app.columns_frame.bind("<Configure>", _update_region)

    # ----------------------------------------------------
    # styled row-builder – overrides app.add_column_row
    # ----------------------------------------------------
    def add_row(col):
        row_bg = "#F9F9F9" if len(app.columns_frame.winfo_children()) % 2 else "white"
        row = tk.Frame(app.columns_frame, bg=row_bg)
        row.pack(fill="x", pady=2, padx=5)

        sel_var = tk.BooleanVar()
        tk.Checkbutton(row, text=col, variable=sel_var, bg=row_bg).grid(row=0, column=0, sticky="w")
        app.column_vars[col] = sel_var

        formula_var = tk.StringVar()
        EntryCls = FormulaEntry if (USE_ENHANCED_UI and FormulaEntry) else tk.Entry
        ent = EntryCls(row, textvariable=formula_var, width=42)
        ent.grid(row=0, column=1, sticky="ew", padx=4)
        ent.bind("<KeyRelease>", lambda _e, c=col: app.update_formula_preview(c))
        app.formula_vars[col] = formula_var

        row.grid_columnconfigure(1, weight=1)

        prev = tk.Label(row, text="", font=("Consolas", 9), fg=PREVIEW_COLOR, bg=row_bg)
        prev.grid(row=1, column=1, sticky="w", padx=4)
        app.preview_labels[col] = prev

    app.add_column_row = add_row
    return outer


================================================================================
FILE: gui\ui\components\config_export_section.py
================================================================================

"""Save / load configuration + export button + recent list."""

import tkinter as tk
from tkinter import ttk, messagebox

from gui.ui.utils import (
    PAD_X, PAD_Y, FIELD_PAD, USE_ENHANCED_UI, create_tooltip
)
from gui.core.config_manager import load_config

# optional enhanced widget
try:
    from gui.ui.custom_widgets import TooltipButton
except ImportError:
    TooltipButton = None


def build(app):
    frame = ttk.LabelFrame(app.root, text="Configuration and Export")
    frame.pack(fill="x", padx=PAD_X, pady=(0, PAD_Y))

    row = ttk.Frame(frame)
    row.pack(fill="x", padx=PAD_X, pady=PAD_Y)

    # --- Save / Load Config ---
    ttk.Button(row, text="Save Config", command=app.save_config) \
        .pack(side="left", padx=(0, FIELD_PAD))
    ttk.Button(row, text="Load Config", command=app.load_config) \
        .pack(side="left", padx=(0, FIELD_PAD))

    # --- Recent Configs Dropdown ---
    ttk.Label(row, text="Recent:").pack(side="left", padx=(FIELD_PAD * 3, FIELD_PAD))
    app.recent_var = tk.StringVar()
    app.recent_combo = ttk.Combobox(
        row,
        textvariable=app.recent_var,
        state="readonly",
        width=48,
        values=app.recent_configs,
    )
    app.recent_combo.pack(side="left", padx=(0, PAD_X))

    def _load_recent(_):
        sel = app.recent_var.get()
        if not sel:
            return
        try:
            cfg = load_config(sel)
            app._apply_loaded_config(cfg)
        except Exception as exc:
            messagebox.showerror("Load Error", exc)

    app.recent_combo.bind("<<ComboboxSelected>>", _load_recent)

    # --- Export Button ---
    if USE_ENHANCED_UI and TooltipButton:
        export_btn = TooltipButton(
            row, text="EXPORT DATA", command=app.export,
            tooltip_text="Process data and write a new Excel file"
        )
    else:
        export_btn = ttk.Button(row, text="EXPORT DATA", command=app.export)

    export_btn.pack(side="right", padx=(FIELD_PAD, 0))
    if USE_ENHANCED_UI:
        create_tooltip(export_btn, "Generate the output Excel")

    # --- Confluence Upload Button ---
    try:
        from gui.confluence.ui import attach_upload_button
        attach_upload_button(row, app)
    except Exception as exc:
        print(f"[Confluence] Upload button attach failed: {exc}")

    return frame


================================================================================
FILE: gui\ui\components\header.py
================================================================================

"""Header bar – shows app title + version."""

import tkinter as tk
from tkinter import ttk
from gui.ui.utils import PRIMARY_COLOR, BG_COLOR, PAD_X, PAD_Y


def build(app):
    """Create the header bar and return the outer frame."""
    frame = ttk.Frame(app.root, padding=(PAD_X * 2, PAD_Y * 2))
    frame.pack(fill="x")

    ttk.Label(
        frame,
        text="Matrix Exporter",
        font=("Segoe UI", 16, "bold"),
        foreground=PRIMARY_COLOR,
        background=BG_COLOR,
    ).pack(side="left")

    ttk.Label(
        frame,
        text="v1.0",
        font=("Segoe UI", 10),
        foreground="#03A9F4",
        background=BG_COLOR,
    ).pack(side="left", padx=(6, 0), pady=(4, 0))

    ttk.Separator(app.root, orient="horizontal").pack(fill="x", padx=PAD_X, pady=(0, PAD_Y))
    return frame


================================================================================
FILE: gui\ui\components\main_file_section.py
================================================================================

"""Main-file chooser + sheet selector."""

import tkinter as tk
from tkinter import ttk
from gui.ui.utils import PAD_X, PAD_Y, FIELD_PAD, BG_COLOR, create_tooltip


def build(app):
    frame = ttk.LabelFrame(app.root, text="Source File")
    frame.pack(fill="x", padx=PAD_X, pady=(0, PAD_Y))

    # --- row 1: choose file, header row, sheet ---
    row = ttk.Frame(frame)
    row.pack(fill="x", padx=PAD_X, pady=PAD_Y)

    btn = ttk.Button(row, text="Load Excel File", command=app.load_main_file)
    btn.pack(side="left")
    create_tooltip(btn, "Select the main workbook")

    ttk.Label(row, text="Header Row:").pack(side="left", padx=FIELD_PAD)
    ttk.Entry(row, textvariable=app.header_row, width=5).pack(side="left")

    ttk.Label(row, text="Sheet:").pack(side="left", padx=(PAD_X, FIELD_PAD))
    app.sheet_dropdown = ttk.Combobox(row, state="readonly", width=24)
    app.sheet_dropdown.pack(side="left")
    app.sheet_dropdown.bind("<<ComboboxSelected>>", app.load_sheet)

    return frame


================================================================================
FILE: gui\ui\components\presets_section.py
================================================================================

"""Preset picker for column formulas/selection."""

import tkinter as tk
from tkinter import ttk
from gui.ui.utils import PAD_X, PAD_Y, create_tooltip


def build(app):
    frame = ttk.LabelFrame(app.root, text="Column Presets")
    frame.pack(fill="x", padx=PAD_X, pady=(0, PAD_Y))

    inner = ttk.Frame(frame)
    inner.pack(fill="x", padx=PAD_X, pady=PAD_Y)

    app.preset_var = tk.StringVar()
    app.preset_dropdown = ttk.Combobox(
        inner,
        textvariable=app.preset_var,
        state="readonly",
        width=32,
        values=list(app.presets.keys()),
    )
    app.preset_dropdown.pack(side="left", fill="x", expand=True)

    btn = ttk.Button(inner, text="Apply", command=app.apply_preset)
    btn.pack(side="left", padx=(PAD_X, 0))
    create_tooltip(btn, "Apply the selected preset to column checks/formulas")

    return frame


================================================================================
FILE: gui\ui\components\reference_join_section.py
================================================================================

"""Widgets for adding a reference workbook join."""

from tkinter import ttk
from gui.ui.utils import PAD_X, PAD_Y, FIELD_PAD


def build(app):
    frame = ttk.LabelFrame(app.root, text="Reference File Join")
    frame.pack(fill="x", padx=PAD_X, pady=(0, PAD_Y))

    inner = ttk.Frame(frame)
    inner.pack(fill="x", padx=PAD_X, pady=PAD_Y)

    ttk.Button(inner, text="Load Reference", command=app.load_reference_file).grid(row=0, column=0, padx=FIELD_PAD)

    ttk.Label(inner, text="Main Key:").grid(row=0, column=1, sticky="e")
    app.main_key_entry = ttk.Entry(inner, width=18)
    app.main_key_entry.grid(row=0, column=2, padx=FIELD_PAD)

    ttk.Label(inner, text="Ref Key:").grid(row=0, column=3, sticky="e")
    app.ref_key_entry = ttk.Entry(inner, width=18)
    app.ref_key_entry.grid(row=0, column=4, padx=FIELD_PAD)

    ttk.Label(inner, text="Ref Columns:").grid(row=0, column=5, sticky="e")
    app.ref_cols_entry = ttk.Entry(inner, width=28)
    app.ref_cols_entry.grid(row=0, column=6, padx=FIELD_PAD)

    inner.columnconfigure(6, weight=1)
    return frame


================================================================================
FILE: gui\ui\components\status_bar.py
================================================================================

"""Bottom status bar that exposes app.update_status()."""

import tkinter as tk
from tkinter import ttk
from gui.ui.utils import PAD_X, PAD_Y, flash_success_message, PREVIEW_COLOR


def build(app):
    frame = ttk.Frame(app.root)
    frame.pack(side="bottom", fill="x", padx=PAD_X, pady=PAD_Y)

    app.status_var = tk.StringVar(value="Ready")
    ttk.Label(frame, textvariable=app.status_var, anchor="w").pack(side="left")

    def update_status(msg, success=None):
        app.status_var.set(msg)
        app.root.update_idletasks()
        if success:
            flash_success_message(app.status_var, msg)

    app.update_status = update_status
    return frame


================================================================================
FILE: gui\ui\custom_widgets.py
================================================================================

import tkinter as tk
from tkinter import ttk
import re

class FormulaEntry(ttk.Frame):
    """Enhanced entry widget with syntax highlighting for formula editing."""
    
    def __init__(self, master=None, textvariable=None, **kwargs):
        # Extract the textvariable before passing kwargs to parent
        self.textvariable = textvariable
        
        # Remove textvariable from kwargs if present
        if 'textvariable' in kwargs:
            del kwargs['textvariable']
            
        # Initialize the frame
        super().__init__(master, **kwargs)
        
        # Create the entry widget
        self.entry = ttk.Entry(self, textvariable=self.textvariable)
        self.entry.pack(fill="x", expand=True)
        
        # Syntax highlighting colors
        self.colors = {
            'functions': '#0D47A1',  # Dark blue for functions
            'operators': '#D32F2F',  # Red for operators
            'brackets': '#2E7D32',   # Green for brackets
            'column_refs': '#7B1FA2', # Purple for column references
            'numbers': '#FF6F00'     # Orange for numbers
        }
        
        # Bind key events for real-time feedback
        self.entry.bind("<KeyRelease>", self.highlight_syntax)
        
    def highlight_syntax(self, event=None):
        """Apply simple syntax highlighting to the formula."""
        # This is a placeholder for actual syntax highlighting
        # In a production app, you might use a Text widget with tags instead
        # But for now, we'll just change the background color based on formula validity
        formula = self.entry.get()
        
        if formula:
            # Very basic validation
            valid = self.validate_formula(formula)
            if valid:
                self.entry.configure(style="Valid.TEntry")
            else:
                self.entry.configure(style="Invalid.TEntry")
        else:
            # Reset to default
            self.entry.configure(style="TEntry")
    
    def validate_formula(self, formula):
        """Basic validation of formula syntax."""
        # Check for balanced brackets
        if formula.count('[') != formula.count(']'):
            return False
        
        # Check for balanced parentheses
        if formula.count('(') != formula.count(')'):
            return False
        
        return True
    
    def get(self):
        """Get the formula text."""
        return self.entry.get()
    
    def set(self, value):
        """Set the formula text."""
        self.entry.delete(0, tk.END)
        self.entry.insert(0, value)
        self.highlight_syntax()


class TooltipButton(ttk.Button):
    """Button with a tooltip that appears on hover."""
    
    def __init__(self, master=None, tooltip_text="", **kwargs):
        super().__init__(master, **kwargs)
        self.tooltip_text = tooltip_text
        
        # Create the tooltip window (hidden initially)
        self.tooltip = None
        
        # Bind mouse events
        self.bind("<Enter>", self.show_tooltip)
        self.bind("<Leave>", self.hide_tooltip)
    
    def show_tooltip(self, event=None):
        """Show the tooltip."""
        if self.tooltip_text:
            x, y, _, _ = self.bbox("insert")
            x += self.winfo_rootx() + 25
            y += self.winfo_rooty() + 25
            
            # Create the tooltip window
            self.tooltip = tk.Toplevel(self)
            self.tooltip.wm_overrideredirect(True)  # Remove window decorations
            self.tooltip.wm_geometry(f"+{x}+{y}")
            
            # Create the label with the tooltip text
            label = ttk.Label(
                self.tooltip, 
                text=self.tooltip_text,
                justify=tk.LEFT,
                background="#FFFFD0",
                relief="solid",
                borderwidth=1,
                font=("Segoe UI", 9),
                padding=(5, 2)
            )
            label.pack()
    
    def hide_tooltip(self, event=None):
        """Hide the tooltip."""
        if self.tooltip:
            self.tooltip.destroy()
            self.tooltip = None


class ProgressDialog(tk.Toplevel):
    """Modal dialog showing progress with an optional cancel button."""
    
    def __init__(self, parent, title="Progress", message="Processing...", 
                 cancellable=False, on_cancel=None):
        super().__init__(parent)
        
        self.title(title)
        self.transient(parent)  # Make dialog a child of parent
        self.grab_set()  # Make dialog modal
        
        # Center the dialog on parent
        window_width = 350
        window_height = 150
        screen_width = parent.winfo_screenwidth()
        screen_height = parent.winfo_screenheight()
        parent_x = parent.winfo_rootx()
        parent_y = parent.winfo_rooty()
        parent_width = parent.winfo_width()
        parent_height = parent.winfo_height()
        
        x = parent_x + (parent_width - window_width) // 2
        y = parent_y + (parent_height - window_height) // 2
        
        self.geometry(f"{window_width}x{window_height}+{x}+{y}")
        
        self.resizable(False, False)
        self.configure(bg="#F5F5F5")
        
        # Create widgets
        self.message_var = tk.StringVar(value=message)
        
        # Message label
        ttk.Label(
            self, 
            textvariable=self.message_var,
            font=("Segoe UI", 11),
            background="#F5F5F5"
        ).pack(pady=(20, 10))
        
        # Progress bar
        self.progress = ttk.Progressbar(
            self, 
            orient="horizontal",
            length=300,
            mode="determinate"
        )
        self.progress.pack(pady=10, padx=25)
        
        # Cancel button (optional)
        if cancellable and on_cancel:
            self.on_cancel = on_cancel
            ttk.Button(
                self,
                text="Cancel",
                command=self.cancel
            ).pack(pady=(10, 20))
        
        # Prevent closing with the window manager
        self.protocol("WM_DELETE_WINDOW", self.do_nothing)
        
        # Ensure dialog appears on top
        self.focus_set()
        
        # Start with 0 progress
        self.set_progress(0)
    
    def set_progress(self, value):
        """Set the progress bar value (0-100)."""
        self.progress["value"] = value
        self.update_idletasks()
    
    def set_message(self, message):
        """Update the message text."""
        self.message_var.set(message)
        self.update_idletasks()
    
    def cancel(self):
        """Cancel the operation."""
        if hasattr(self, 'on_cancel'):
            self.on_cancel()
        self.destroy()
    
    def do_nothing(self):
        """Prevent closing with the window manager."""
        pass
    
    def finish(self):
        """Complete the progress and close."""
        self.set_progress(100)
        self.update_idletasks()
        self.after(500, self.destroy)


class FileDragDrop(ttk.LabelFrame):
    """Frame that supports dragging and dropping files."""
    
    def __init__(self, master=None, on_drop=None, **kwargs):
        super().__init__(master, **kwargs)
        
        self.on_drop = on_drop
        
        # Create a label for instructions
        self.label = ttk.Label(
            self,
            text="Drag and drop Excel files here",
            font=("Segoe UI", 11),
            foreground="#757575",
            background="#FFFFFF",
            anchor="center"
        )
        self.label.pack(fill="both", expand=True, padx=20, pady=20)
        
        # Create a border around the label
        self.label.configure(borderwidth=2, relief="groove")
        
        # Bind events for drag and drop
        self.label.bind("<Enter>", self.on_enter)
        self.label.bind("<Leave>", self.on_leave)
        
        # These are the actual drag-and-drop event bindings
        # Note: Tkinter doesn't natively support drag and drop
        # This is a placeholder showing how you would bind the events
        # In a real implementation, you might need platform-specific code
        # or third-party libraries like tkinterdnd2
        #self.label.bind("<Drop>", self.on_file_drop)
        
    def on_enter(self, event):
        """Mouse entered the drop zone."""
        self.label.configure(foreground="#1976D2", text="Release to drop files")
    
    def on_leave(self, event):
        """Mouse left the drop zone."""
        self.label.configure(foreground="#757575", text="Drag and drop Excel files here")
    
    def on_file_drop(self, event):
        """File was dropped in the drop zone."""
        if self.on_drop:
            # In a real implementation, you would get the file path from the event
            # For now, we'll just call the callback with None
            self.on_drop(None)
        
        # Reset appearance
        self.on_leave(event)

================================================================================
FILE: gui\ui\export_filename_customizer.py
================================================================================

# File: export_filename_customizer.py
# Location: gui/ui/components/

import tkinter as tk
from tkinter import ttk, filedialog, messagebox
from datetime import datetime
from gui.confluence.settings import load_confluence_settings
from gui.confluence.uploader import upload_to_page

class ExportFilenameCustomizer(tk.Frame):
    def __init__(self, master, on_export):
        super().__init__(master)
        self.on_export = on_export

        # --- Title dropdown ---
        self.title_var = tk.StringVar()
        ttk.Label(self, text="Export Title:").grid(row=0, column=0, padx=5, pady=5, sticky="e")
        self.title_dropdown = ttk.Combobox(self, textvariable=self.title_var, state="readonly")
        self.title_dropdown['values'] = ["Sales_Report", "Inventory_Snapshot", "Monthly_Review"]
        self.title_dropdown.current(0)
        self.title_dropdown.grid(row=0, column=1, padx=5, pady=5)

        # --- Date (today by default) ---
        self.date_var = tk.StringVar(value=datetime.today().strftime("%Y-%m-%d"))
        ttk.Label(self, text="Date:").grid(row=0, column=2, padx=5, pady=5, sticky="e")
        self.date_entry = ttk.Entry(self, textvariable=self.date_var, width=12)
        self.date_entry.grid(row=0, column=3, padx=5, pady=5)

        # --- Filename preview ---
        self.preview_var = tk.StringVar()
        self.update_preview()
        self.title_var.trace_add('write', lambda *_: self.update_preview())
        self.date_var.trace_add('write', lambda *_: self.update_preview())

        ttk.Label(self, text="Filename Preview:").grid(row=1, column=0, padx=5, pady=5, sticky="e")
        ttk.Label(self, textvariable=self.preview_var, foreground="gray").grid(row=1, column=1, columnspan=3, sticky="w")

        # --- Export Button ---
        ttk.Button(self, text="Export", command=self.handle_export).grid(row=2, column=3, padx=5, pady=10, sticky="e")

        # --- Upload Button ---
        ttk.Button(self, text="Upload to Confluence", command=self.handle_upload).grid(row=2, column=2, padx=5, pady=10, sticky="e")

    def update_preview(self):
        title = self.title_var.get()
        date = self.date_var.get()
        self.preview_var.set(f"{title}_{date}.xlsx")

    def handle_export(self):
        suggested_name = self.preview_var.get()
        out_path = filedialog.asksaveasfilename(
            defaultextension=".xlsx",
            initialfile=suggested_name,
            filetypes=[("Excel files", "*.xlsx"), ("All files", "*.*")]
        )
        if out_path:
            self.exported_path = out_path  # Store for Confluence upload
            self.on_export(out_path)

    def handle_upload(self):
        if not hasattr(self, 'exported_path') or not self.exported_path:
            messagebox.showwarning("Missing File", "Please export the Excel file first.")
            return

        settings = load_confluence_settings()
        if not settings:
            messagebox.showwarning("No Settings", "Please configure Confluence settings first.")
            return

        page_id = tk.simpledialog.askstring("Confluence Page ID", "Enter Confluence Page ID:")
        if not page_id:
            return

        try:
            upload_to_page(self.exported_path, page_id)
            messagebox.showinfo("Success", f"Uploaded to Confluence page {page_id}")
        except Exception as e:
            messagebox.showerror("Upload Failed", str(e))

# Example usage:
if __name__ == "__main__":
    def dummy_export(path):
        messagebox.showinfo("Exporting", f"Would export to:\n{path}")

    root = tk.Tk()
    root.title("Export UI")
    ExportFilenameCustomizer(root, on_export=dummy_export).pack(padx=10, pady=10)
    root.mainloop()


================================================================================
FILE: gui\ui\helpers\__init__.py
================================================================================



================================================================================
FILE: gui\ui\helpers\dialogs.py
================================================================================

"""Extracted from utils.py – generated by split_utils.py."""

def show_info_message(parent, title, message):
    """Show an information message with enhanced styling."""
    messagebox.showinfo(title, message)

def show_error_message(parent, title, message):
    """Show an error message with enhanced styling."""
    messagebox.showerror(title, message)

def show_warning_message(parent, title, message):
    """Show a warning message with enhanced styling."""
    messagebox.showwarning(title, message)

def show_confirmation_dialog(parent, title, message):
    """Show a confirmation dialog and return True if confirmed."""
    return messagebox.askyesno(title, message)


================================================================================
FILE: gui\ui\helpers\file_utils.py
================================================================================

"""Extracted from utils.py – generated by split_utils.py."""

def save_app_settings(settings, filename="app_settings.json"):
    """Save application settings to a JSON file."""
    try:
        with open(filename, 'w') as f:
            json.dump(settings, f, indent=2)
        return True
    except Exception as e:
        print(f"Error saving settings: {e}")
        return False

def load_app_settings(filename="app_settings.json"):
    """Load application settings from a JSON file."""
    if not os.path.exists(filename):
        return {}
    
    try:
        with open(filename, 'r') as f:
            return json.load(f)
    except Exception as e:
        print(f"Error loading settings: {e}")
        return {}

def create_backup_file(filepath, suffix="_backup"):
    """Create a backup of a file with timestamp."""
    if not os.path.exists(filepath):
        return None
    
    # Get the file name and extension
    file_dir, file_name = os.path.split(filepath)
    name, ext = os.path.splitext(file_name)
    
    # Create a timestamp
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    
    # Create the backup file name
    backup_name = f"{name}{suffix}_{timestamp}{ext}"
    backup_path = os.path.join(file_dir, backup_name)
    
    # Copy the file
    try:
        import shutil
        shutil.copy2(filepath, backup_path)
        return backup_path
    except Exception as e:
        print(f"Error creating backup: {e}")
        return None


================================================================================
FILE: gui\ui\helpers\palette.py
================================================================================

# --- global spacing constants (were in the old utils.py)
PAD_X      = 8      # horizontal padding
PAD_Y      = 5      # vertical padding
FIELD_PAD  = 3      # label-entry gap

# --- feature flag: does the enhanced UI toolkit import?
try:
    from gui.ui.custom_widgets import FormulaEntry, TooltipButton, ProgressDialog
    USE_ENHANCED_UI = True
except ImportError:
    USE_ENHANCED_UI = False

"""Extracted from utils.py – generated by split_utils.py."""

# Color palette for a consistent look
PRIMARY_COLOR = "#1976D2"  # Material blue
SECONDARY_COLOR = "#42A5F5"  # Lighter blue
ACCENT_COLOR = "#FF9800"  # Orange accent
BG_COLOR = "#F5F5F5"  # Light grey background
TEXT_COLOR = "#212121"  # Dark text
PREVIEW_COLOR = "#607D8B"  # Blue grey for preview text
HEADER_COLOR = "#0D47A1"  # Dark blue for headers
SUCCESS_COLOR = "#4CAF50"  # Green for success indicators


================================================================================
FILE: gui\ui\helpers\statusbar.py
================================================================================

"""Extracted from utils.py – generated by split_utils.py."""

def create_status_bar(root, initial_message="Ready"):
    """Create a status bar at the bottom of the root window."""
    status_frame = ttk.Frame(root)
    status_frame.pack(side="bottom", fill="x", padx=5, pady=2)
    
    # Create a variable to hold the status text
    status_var = tk.StringVar(value=initial_message)
    
    # Create the status label
    status_label = ttk.Label(
        status_frame,
        textvariable=status_var,
        anchor="w",
        font=("Segoe UI", 9)
    )
    status_label.pack(side="left")
    
    # Return both the frame and the variable so they can be accessed later
    return status_frame, status_var

def flash_success_message(status_var, message, duration=3000):
    """Flash a success message in the status bar temporarily."""
    # Save the original message
    original_message = status_var.get()
    
    # Set the success message
    status_var.set(f"✓ {message}")
    
    # Schedule restoring the original message
    root = status_var.master.winfo_toplevel()
    root.after(duration, lambda: status_var.set(original_message))

def flash_error_message(status_var, message, duration=3000):
    """Flash an error message in the status bar temporarily."""
    # Save the original message
    original_message = status_var.get()
    
    # Set the error message
    status_var.set(f"❌ {message}")
    
    # Schedule restoring the original message
    root = status_var.master.winfo_toplevel()
    root.after(duration, lambda: status_var.set(original_message))


================================================================================
FILE: gui\ui\helpers\tooltips.py
================================================================================

import tkinter as tk          # ← add this
from tkinter import ttk       # ← and this

"""Extracted from utils.py – generated by split_utils.py."""
# …rest of the file unchanged …

"""Extracted from utils.py – generated by split_utils.py."""

def create_tooltip(widget, text):
    """Create a tooltip for a widget."""
    tooltip = None
    
    def enter(event):
        nonlocal tooltip
        x, y, _, _ = widget.bbox("insert")
        x += widget.winfo_rootx() + 25
        y += widget.winfo_rooty() + 25
        
        # Create a toplevel window
        tooltip = tk.Toplevel(widget)
        tooltip.wm_overrideredirect(True)
        tooltip.wm_geometry(f"+{x}+{y}")
        
        # Create the label
        label = ttk.Label(
            tooltip,
            text=text,
            justify=tk.LEFT,
            background="#FFFFD0",
            relief="solid",
            borderwidth=1,
            font=("Segoe UI", 9),
            padding=(5, 2)
        )
        label.pack()
    
    def leave(event):
        nonlocal tooltip
        if tooltip:
            tooltip.destroy()
            tooltip = None
    
    # Bind events to the widget
    widget.bind("<Enter>", enter)
    widget.bind("<Leave>", leave)

def create_help_button(parent, help_text):
    """Create a help button that shows a tooltip with provided text."""
    button = ttk.Button(
        parent,
        text="?",
        width=2,
        command=lambda: show_info_message(parent, "Help", help_text)
    )
    
    # Add a tooltip to the button
    create_tooltip(button, "Click for help")
    
    return button


================================================================================
FILE: gui\ui\helpers\window.py
================================================================================

# gui/ui/helpers/window.py
try:
    from gui.ui.custom_widgets import FormulaEntry, TooltipButton, ProgressDialog
    USE_ENHANCED_UI = True
except ImportError:
    USE_ENHANCED_UI = False

"""Extracted from utils.py – generated by split_utils.py."""

def apply_modern_theme(root):
    """Apply a modern theme to the application."""
    style = ttk.Style()
    
    # Try to use a modern-looking theme if available
    available_themes = style.theme_names()
    
    # Preferred themes in order
    preferred_themes = ["clam", "vista", "xpnative", "winnative", "default"]
    
    # Find the first available preferred theme
    for theme in preferred_themes:
        if theme in available_themes:
            style.theme_use(theme)
            break
    
    # Configure common styles
    style.configure("TFrame", background=BG_COLOR)
    style.configure("TLabel", background=BG_COLOR, foreground=TEXT_COLOR, font=("Segoe UI", 10))
    style.configure("TButton", font=("Segoe UI", 10), padding=5)
    style.configure("TEntry", padding=3)
    style.configure("TCheckbutton", background=BG_COLOR, font=("Segoe UI", 10))
    
    # Special button styles
    style.configure("Primary.TButton",
                   font=("Segoe UI", 10, "bold"),
                   padding=5)
    
    style.configure("Success.TButton",
                   font=("Segoe UI", 11, "bold"),
                   padding=6)
    
    # Configure the root window
    root.configure(background=BG_COLOR)

def center_window(window, width=None, height=None):
    """Center a window on the screen with optional size."""
    # Set size if provided
    if width and height:
        window.geometry(f"{width}x{height}")
    
    # Get window size
    window.update_idletasks()
    window_width = window.winfo_width()
    window_height = window.winfo_height()
    
    # Calculate position
    screen_width = window.winfo_screenwidth()
    screen_height = window.winfo_screenheight()
    x = (screen_width - window_width) // 2
    y = (screen_height - window_height) // 2
    
    # Set position
    window.geometry(f"+{x}+{y}")


================================================================================
FILE: gui\ui\init.py
================================================================================

# This file makes the gui/ui directory a Python package
# Import common UI components for easier access

try:
    from gui.ui.utils import (
        create_tooltip, show_info_message, show_error_message,
        flash_success_message, flash_error_message,
        apply_modern_theme, center_window
    )
    
    from gui.ui.theme import apply_theme
    
    from gui.ui.custom_widgets import (
        FormulaEntry, TooltipButton, ProgressDialog, FileDragDrop
    )
    
    # Indicate that enhanced UI is available
    ENHANCED_UI_AVAILABLE = True
    
except ImportError:
    # Fallback if some modules are missing
    ENHANCED_UI_AVAILABLE = False
    
    def dummy_function(*args, **kwargs):
        """Dummy function for fallback."""
        pass
    
    # Create dummy functions to prevent errors
    create_tooltip = dummy_function
    show_info_message = dummy_function
    show_error_message = dummy_function
    flash_success_message = dummy_function
    flash_error_message = dummy_function
    apply_modern_theme = dummy_function
    center_window = dummy_function

================================================================================
FILE: gui\ui\layout copy.py
================================================================================

import tkinter as tk
from tkinter import ttk

# Global padding constants
PAD_X = 6
PAD_Y = 3
FIELD_PAD = 2

def build_layout(app):
    style = ttk.Style()
    style.theme_use("clam")
    style.configure("TLabel", font=("Segoe UI", 10))
    style.configure("TButton", font=("Segoe UI", 10))
    style.configure("TCheckbutton", font=("Segoe UI", 10))

    # === Main Excel File Frame ===
    file_frame = ttk.LabelFrame(app.root, text="Main Excel File")
    file_frame.pack(padx=PAD_X, pady=(PAD_Y, 2), fill="x")

    ttk.Button(file_frame, text="Load Main Excel File", command=app.load_main_file).pack(side="left", padx=(PAD_X, FIELD_PAD), pady=PAD_Y)
    ttk.Label(file_frame, text="Header Row:").pack(side="left", padx=(FIELD_PAD, FIELD_PAD))
    ttk.Entry(file_frame, textvariable=app.header_row, width=5).pack(side="left", padx=(FIELD_PAD, PAD_X))

    app.sheet_dropdown = ttk.Combobox(file_frame, state="readonly")
    app.sheet_dropdown.pack(side="left", padx=FIELD_PAD)
    app.sheet_dropdown.bind("<<ComboboxSelected>>", app.load_sheet)

    # === Presets Frame ===
    preset_frame = ttk.LabelFrame(app.root, text="Column Presets")
    preset_frame.pack(padx=PAD_X, pady=(0, 2), fill="x")

    app.preset_var = tk.StringVar()
    app.preset_dropdown = ttk.Combobox(preset_frame, state="readonly", textvariable=app.preset_var)
    app.preset_dropdown.pack(side="left", padx=(PAD_X, FIELD_PAD))
    ttk.Button(preset_frame, text="Apply Preset", command=app.apply_preset).pack(side="left", padx=(FIELD_PAD, PAD_X))

    # === Column Controls (Check + Formula) ===
    columns_container = ttk.Frame(app.root)
    columns_container.pack(padx=PAD_X, pady=(0, PAD_Y), fill="both", expand=True)

    canvas = tk.Canvas(columns_container, borderwidth=0, highlightthickness=0, bg="#f8f8f8")
    canvas.grid_propagate(False)
    scrollbar = ttk.Scrollbar(columns_container, orient="vertical", command=canvas.yview)
    app.columns_frame = ttk.Frame(canvas, style="TFrame")
    app.column_rows = {}
    app.columns_frame.columnconfigure(1, weight=1)

    app.columns_frame.bind(
        "<Configure>",
        lambda e: canvas.configure(
            scrollregion=canvas.bbox("all")
        )
    )

    canvas_window = canvas.create_window((0, 0), window=app.columns_frame, anchor="nw", width=canvas.winfo_reqwidth())
    canvas.configure(yscrollcommand=scrollbar.set)

    canvas.pack(side="left", fill="both", expand=True, padx=0, pady=0)
    scrollbar.pack(side="right", fill="y")

    # Add consistent background color
    style.configure("TFrame", background="#f8f8f8")
    style.configure("TLabelFrame", background="#f8f8f8")
    style.configure("TCheckbutton", background="#f8f8f8")
    style.configure("TEntry", relief="flat")


    join_frame = ttk.LabelFrame(app.root, text="Reference File Join")
    join_frame.pack(padx=PAD_X, pady=(0, PAD_Y), fill="x")

    ttk.Button(join_frame, text="Load Reference File", command=app.load_reference_file).grid(row=0, column=0, padx=FIELD_PAD, pady=PAD_Y)

    ttk.Label(join_frame, text="Main Key:").grid(row=0, column=1, padx=FIELD_PAD)
    app.main_key_entry = ttk.Entry(join_frame)
    app.main_key_entry.grid(row=0, column=2, padx=FIELD_PAD)

    ttk.Label(join_frame, text="Ref Key:").grid(row=0, column=3, padx=FIELD_PAD)
    app.ref_key_entry = ttk.Entry(join_frame)
    app.ref_key_entry.grid(row=0, column=4, padx=FIELD_PAD)

    ttk.Label(join_frame, text="Ref Columns:").grid(row=0, column=5, padx=FIELD_PAD)
    app.ref_cols_entry = ttk.Entry(join_frame)
    app.ref_cols_entry.grid(row=0, column=6, padx=FIELD_PAD)

    # === Save/Load + Export Frame ===
    config_frame = ttk.LabelFrame(app.root, text="Save/Load + Export")
    config_frame.pack(padx=PAD_X, pady=(0, PAD_Y + 2), fill="x")

    ttk.Button(config_frame, text="Save Config", command=app.save_config).pack(side="left", padx=(PAD_X, FIELD_PAD))
    ttk.Button(config_frame, text="Load Config", command=app.load_config).pack(side="left", padx=FIELD_PAD)
    ttk.Button(config_frame, text="Export", command=app.export).pack(side="right", padx=(FIELD_PAD, PAD_X))


================================================================================
FILE: gui\ui\layout.py
================================================================================

"""Slim orchestrator (auto‑generated but now tweaked).
Splits widget construction across helper components in ``gui.ui.components``.

Each component module *must* expose a ``build(app)`` function that packs its
widgets into the already‑configured root window.
"""

from gui.ui.theme import apply_theme
from gui.ui import utils as U

# ---------------------------------------------------------------------------
# Import the component modules. Ensure every name below matches a real file
#   gui/ui/components/<name>.py
# ---------------------------------------------------------------------------
from gui.ui.components import (
    header,                  # header.py
    main_file_section,       # main_file_section.py
    presets_section,         # presets_section.py
    column_controls_section, # column_controls_section.py
    reference_join_section,  # reference_join_section.py
    config_export_section,   # config_export_section.py
    status_bar,              # status_bar.py
)

# ---------------------------------------------------------------------------
# Tiny debug helper – prints which component failed to build and how many
# widgets hang directly off the root afterwards. Remove when you’re happy.
# ---------------------------------------------------------------------------

def _safe_build(tag: str, fn, app):
    """Run *fn(app)* and ensure its widget gets packed.

    * Logs progress and the direct‑child count on the root.
    * If the builder returns a Tk widget that is **not** yet managed
      (``winfo_manager() == ''``), we ``pack(fill='x')`` it so the UI doesn’t
      stay blank when a component forgets to call ``pack()``.
    """
    try:
        print(f" >> building {tag}")
        widget = fn(app)

        # auto‑pack if builder forgot
        if widget is not None and hasattr(widget, "winfo_manager") and not widget.winfo_manager():
            widget.pack(fill="x", pady=2)

        print(f"    -> root now has {len(app.root.winfo_children())} direct children")

    except Exception as exc:
        # Log the failure tag once, then propagate the traceback
        print(f" !! {tag} failed: {exc}")
        raise


# ---------------------------------------------------------------------------
# Public entry point – called from gui/app.py
# ---------------------------------------------------------------------------

def build_layout(app):
    """Configure the root window, then delegate to each section builder."""
    # Enhanced theme (if available)
    if getattr(U, "USE_ENHANCED_UI", False):
        app.theme = apply_theme(app.root)

    # Basic window properties
    app.root.title("Matrix Exporter")
    app.root.geometry("1100x700")
    app.root.minsize(900, 600)

    # Build UI sections in order
    _safe_build("header",                   header.build, app)
    _safe_build("main_file_section",        main_file_section.build, app)
    _safe_build("presets_section",          presets_section.build, app)
    _safe_build("column_controls_section",  column_controls_section.build, app)
    _safe_build("reference_join_section",   reference_join_section.build, app)
    _safe_build("config_export_section",    config_export_section.build, app)
    _safe_build("status_bar",               status_bar.build, app)

    return app


================================================================================
FILE: gui\ui\theme.py
================================================================================

import tkinter as tk
from tkinter import ttk, font
import os

class MatrixTheme:
    """Theme manager for the Matrix Ingestor application."""
    
    # Theme color constants
    COLORS = {
        "primary": "#1976D2",        # Primary blue
        "primary_dark": "#0D47A1",   # Darker blue
        "primary_light": "#42A5F5",  # Lighter blue
        "secondary": "#FF9800",      # Orange accent
        "secondary_dark": "#F57C00", # Darker orange
        "secondary_light": "#FFB74D",# Lighter orange
        "success": "#4CAF50",        # Green for success
        "error": "#F44336",          # Red for errors
        "warning": "#FFC107",        # Yellow for warnings
        "info": "#2196F3",           # Blue for info
        "bg_light": "#F5F5F5",       # Light grey background
        "bg_white": "#FFFFFF",       # White background
        "bg_alt": "#F9F9F9",         # Alternate row background
        "text": "#212121",           # Main text color
        "text_secondary": "#757575", # Secondary text color
        "border": "#E0E0E0",         # Border color
        "disabled": "#BDBDBD",       # Disabled element color
        "highlight": "#E3F2FD",      # Highlight background
        "tooltip": "#FFFFD0"         # Tooltip background
    }
    
    # Font configurations
    FONTS = {
        "header": ("Segoe UI", 16, "bold"),
        "subheader": ("Segoe UI", 12, "bold"),
        "body": ("Segoe UI", 10),
        "body_bold": ("Segoe UI", 10, "bold"),
        "small": ("Segoe UI", 9),
        "tiny": ("Segoe UI", 8),
        "monospace": ("Consolas", 9)
    }
    
    def __init__(self, root):
        """Initialize the theme manager.
        
        Args:
            root: The root tkinter window
        """
        self.root = root
        self.style = ttk.Style()
        
        # Configure the theme
        self.configure_theme()
    
    def configure_theme(self):
        """Configure the application theme."""
        # Choose the best available theme as base
        self._set_base_theme()
        
        # Configure colors and styles
        self._configure_colors()
        self._configure_styles()
        
        # Set window icon if available
        self._set_window_icon()
    
    def _set_base_theme(self):
        """Set the base ttk theme."""
        # Prefer 'clam' theme as it's the most customizable cross-platform
        available_themes = self.style.theme_names()
        preferred_themes = ["clam", "vista", "xpnative", "winnative", "default"]
        
        # Use the first available preferred theme
        for theme in preferred_themes:
            if theme in available_themes:
                self.style.theme_use(theme)
                break
        
        # Configure the root window
        self.root.configure(background=self.COLORS["bg_light"])
    
    def _configure_colors(self):
        """Configure the color scheme."""
        # Set root background
        self.root.configure(background=self.COLORS["bg_light"])
        
        # Other widget colors are set in _configure_styles
    
    def _configure_styles(self):
        """Configure ttk widget styles."""
        # Frame styles
        self.style.configure("TFrame", background=self.COLORS["bg_light"])
        self.style.configure("Card.TFrame", background=self.COLORS["bg_white"], 
                            relief="raised", borderwidth=1)
        
        # Label styles
        self.style.configure("TLabel", background=self.COLORS["bg_light"], 
                            foreground=self.COLORS["text"], font=self.FONTS["body"])
        self.style.configure("Header.TLabel", background=self.COLORS["bg_light"], 
                            foreground=self.COLORS["primary"], font=self.FONTS["header"])
        self.style.configure("Subheader.TLabel", background=self.COLORS["bg_light"], 
                            foreground=self.COLORS["primary_dark"], font=self.FONTS["subheader"])
        self.style.configure("Small.TLabel", background=self.COLORS["bg_light"], 
                            foreground=self.COLORS["text_secondary"], font=self.FONTS["small"])
        
        # Button styles
        self.style.configure("TButton", font=self.FONTS["body"], padding=5)
        self.style.map("TButton", 
                      foreground=[("active", self.COLORS["primary_dark"])],
                      background=[("active", self.COLORS["highlight"])])
        
        # Primary button style
        self.style.configure("Primary.TButton", font=self.FONTS["body_bold"], padding=5)
        self.style.map("Primary.TButton", 
                      foreground=[("active", self.COLORS["primary_dark"])],
                      background=[("active", self.COLORS["highlight"])])
        
        # Success button style
        self.style.configure("Success.TButton", font=self.FONTS["body_bold"], padding=6)
        self.style.map("Success.TButton", 
                      foreground=[("active", self.COLORS["success"])],
                      background=[("active", self.COLORS["highlight"])])
        
        # Entry styles
        self.style.configure("TEntry", padding=3)
        
        # Valid and invalid entry styles for formula validation
        self.style.configure("Valid.TEntry", padding=3, fieldbackground="#E8F5E9")  # Light green
        self.style.configure("Invalid.TEntry", padding=3, fieldbackground="#FFEBEE")  # Light red
        
        # Combobox styles
        self.style.configure("TCombobox", padding=3)
        
        # Checkbutton styles
        self.style.configure("TCheckbutton", background=self.COLORS["bg_light"], 
                            font=self.FONTS["body"])
        
        # Labelframe styles
        self.style.configure("TLabelframe", background=self.COLORS["bg_light"])
        self.style.configure("TLabelframe.Label", background=self.COLORS["bg_light"], 
                            foreground=self.COLORS["primary_dark"], font=self.FONTS["body_bold"])
        
        # Separator styles
        self.style.configure("TSeparator", background=self.COLORS["border"])
        
        # Progressbar styles
        self.style.configure("TProgressbar", thickness=8)
        
        # Scrollbar styles
        self.style.configure("TScrollbar", arrowsize=13)
        
        # Notebook styles
        self.style.configure("TNotebook", background=self.COLORS["bg_light"])
        self.style.configure("TNotebook.Tab", font=self.FONTS["body"], padding=[10, 3])
        
        # Alternative row styles for listboxes, treeviews, etc.
        self.style.configure("Even.TFrame", background=self.COLORS["bg_white"])
        self.style.configure("Odd.TFrame", background=self.COLORS["bg_alt"])
    
    def _set_window_icon(self):
        """Set the application window icon if available."""
        # Check for common icon locations
        icon_paths = [
            os.path.join("assets", "icon.ico"),
            os.path.join("assets", "icon.png"),
            os.path.join("gui", "assets", "icon.ico"),
            os.path.join("gui", "assets", "icon.png")
        ]
        
        # Try to set the icon
        for path in icon_paths:
            if os.path.exists(path):
                try:
                    self.root.iconbitmap(path) if path.endswith('.ico') else None
                    # For PNG, you would need PIL/Pillow to convert to a Tkinter photo image
                    break
                except Exception:
                    pass
    
    def create_tooltip(self, widget, text):
        """Create a tooltip for a widget.
        
        Args:
            widget: The widget to attach the tooltip to
            text: The tooltip text
        """
        tooltip = None
        
        def enter(event):
            nonlocal tooltip
            x, y, _, _ = widget.bbox("insert")
            x += widget.winfo_rootx() + 25
            y += widget.winfo_rooty() + 25
            
            # Create a toplevel window
            tooltip = tk.Toplevel(widget)
            tooltip.wm_overrideredirect(True)
            tooltip.wm_geometry(f"+{x}+{y}")
            
            # Create the label
            label = ttk.Label(
                tooltip,
                text=text,
                justify=tk.LEFT,
                background=self.COLORS["tooltip"],
                relief="solid",
                borderwidth=1,
                font=self.FONTS["small"],
                padding=(5, 2)
            )
            label.pack()
        
        def leave(event):
            nonlocal tooltip
            if tooltip:
                tooltip.destroy()
                tooltip = None
        
        # Bind events to the widget
        widget.bind("<Enter>", enter)
        widget.bind("<Leave>", leave)
    
    def apply_alternating_row_style(self, parent, widgets):
        """Apply alternating row styles to a list of widgets.
        
        Args:
            parent: The parent widget
            widgets: A list of widgets to style
        """
        # Create alternating row styles
        for i, widget in enumerate(widgets):
            style_name = "Even.TFrame" if i % 2 == 0 else "Odd.TFrame"
            widget.configure(style=style_name)


def apply_theme(root):
    """Apply the Matrix theme to the application.
    
    Args:
        root: The root tkinter window
        
    Returns:
        The theme manager instance
    """
    theme = MatrixTheme(root)
    return theme

================================================================================
FILE: gui\ui\utils.py
================================================================================

"""Facade that re-exports symbols from gui.ui.helpers.*"""

from importlib import import_module as _imp
__all__ = []
for _mod in [
    'palette', 'tooltips', 'dialogs', 'statusbar', 'window', 'file_utils']:
    m = _imp(f'gui.ui.helpers.{_mod}')
    globals().update({k:v for k,v in m.__dict__.items() if not k.startswith('_')})
    __all__.extend([k for k in m.__dict__ if not k.startswith('_')])


================================================================================
FILE: main.py
================================================================================

# main.py

import tkinter as tk
from gui.app import ExcelTransformerApp

if __name__ == "__main__":
    root = tk.Tk()
    app = ExcelTransformerApp(root)
    root.mainloop()


================================================================================
FILE: read2txt.py
================================================================================

import os
import fnmatch
import glob
import sys
from datetime import datetime

def should_include_file(file_path, patterns, verbose=False):
    """
    Determine if a file should be included based on gitignore patterns.
    With a deny-all approach, file needs to match at least one include pattern.
    """
    # Convert file path to use forward slashes for consistency
    file_path = file_path.replace('\\', '/')
    
    # Start with not included since the gitignore has a deny-all pattern
    included = False
    
    if verbose:
        print(f"Checking file: {file_path}")
    
    for pattern in patterns:
        # Check include patterns (starting with !)
        if pattern.startswith('!'):
            clean_pattern = pattern[1:]  # Remove the ! prefix
            if fnmatch.fnmatch(file_path, clean_pattern):
                if verbose:
                    print(f"  Included due to pattern: {pattern}")
                included = True
        # Check exclude patterns (regular patterns)
        else:
            if fnmatch.fnmatch(file_path, pattern):
                if verbose:
                    print(f"  Excluded due to pattern: {pattern}")
                included = False
    
    return included

def parse_gitignore(gitignore_path, verbose=False):
    """Parse the .gitignore file and return separate include and exclude patterns."""
    if not os.path.exists(gitignore_path):
        if verbose:
            print(f"No .gitignore found at {gitignore_path}")
        return []
    
    with open(gitignore_path, 'r', encoding='utf-8') as f:
        lines = f.readlines()
    
    if verbose:
        print(f"Read {len(lines)} lines from .gitignore")
    
    patterns = []
    for line in lines:
        # Remove comments and whitespace
        line = line.split('#')[0].strip()
        
        # Skip empty lines
        if not line:
            continue
        
        # Add the pattern
        patterns.append(line)
        
        # Special handling for directory patterns
        if line.endswith('/') and not line.startswith('!'):
            # Add a pattern to match all files in that directory
            patterns.append(f"{line}**")
    
    if verbose:
        print(f"Parsed {len(patterns)} patterns from .gitignore")
        for pattern in patterns:
            print(f"  Pattern: {pattern}")
    
    return patterns

def is_binary_file(file_path):
    """Check if a file is binary by attempting to read it as text."""
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            f.read(1024)  # Try to read as text
        return False
    except UnicodeDecodeError:
        return True
    except Exception as e:
        print(f"Error checking if {file_path} is binary: {str(e)}")
        return True  # Assume binary if there's an error

def find_included_files(root_dir, gitignore_patterns, verbose=False):
    """Find all files that should be included based on gitignore patterns."""
    included_files = []
    excluded_files = []
    binary_files = []
    error_files = []
    
    if verbose:
        print(f"Searching for files in {root_dir}")
    
    for dirpath, dirnames, filenames in os.walk(root_dir):
        # Skip .git directory
        if '.git' in dirpath.split(os.sep):
            continue
        
        for filename in filenames:
            file_path = os.path.join(dirpath, filename)
            rel_path = os.path.relpath(file_path, root_dir)
            
            # Skip app.txt (our output file)
            if filename == 'app.txt':
                continue
            
            try:
                # Check if file is binary
                if is_binary_file(file_path):
                    if verbose:
                        print(f"  Skipping binary file: {rel_path}")
                    binary_files.append(rel_path)
                    continue
                
                # Check if file should be included
                rel_path_unix = rel_path.replace('\\', '/')
                if should_include_file(rel_path_unix, gitignore_patterns, verbose):
                    if verbose:
                        print(f"  File is included: {rel_path}")
                    included_files.append(file_path)
                else:
                    if verbose:
                        print(f"  File is excluded: {rel_path}")
                    excluded_files.append(rel_path)
            except Exception as e:
                if verbose:
                    print(f"  Error processing file {rel_path}: {str(e)}")
                error_files.append((rel_path, str(e)))
    
    if verbose:
        print(f"Found {len(included_files)} included files")
        print(f"Excluded {len(excluded_files)} files based on gitignore patterns")
        print(f"Skipped {len(binary_files)} binary files")
        print(f"Encountered errors with {len(error_files)} files")
    
    return included_files

def create_app_txt(files, output_path, verbose=False):
    """Create a single file with contents of all included files."""
    if not files:
        if verbose:
            print("No files to write to app.txt")
        with open(output_path, 'w', encoding='utf-8') as out_file:
            out_file.write("No files found to include in app.txt")
        return
    
    successfully_written = 0
    failed_to_write = 0
    
    with open(output_path, 'w', encoding='utf-8') as out_file:
        out_file.write(f"App Content Summary\n")
        out_file.write(f"Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        out_file.write(f"Total Files: {len(files)}\n\n")
        
        for file_path in files:
            try:
                with open(file_path, 'r', encoding='utf-8') as in_file:
                    rel_path = os.path.relpath(file_path)
                    out_file.write(f"\n\n{'='*80}\n")
                    out_file.write(f"FILE: {rel_path}\n")
                    out_file.write(f"{'='*80}\n\n")
                    
                    content = in_file.read()
                    out_file.write(content)
                    
                    if verbose:
                        print(f"Added {rel_path} to app.txt ({len(content)} characters)")
                    
                    successfully_written += 1
            except Exception as e:
                out_file.write(f"\n\n{'='*80}\n")
                out_file.write(f"FILE: {rel_path}\n")
                out_file.write(f"ERROR: Could not read file: {str(e)}\n")
                out_file.write(f"{'='*80}\n\n")
                
                if verbose:
                    print(f"Error writing {file_path} to app.txt: {str(e)}")
                
                failed_to_write += 1
    
    if verbose:
        print(f"Successfully wrote {successfully_written} files to app.txt")
        print(f"Failed to write {failed_to_write} files")

def main():
    # Enable verbose mode
    verbose = True
    
    # Get the project root directory (current directory)
    root_dir = os.getcwd()
    
    if verbose:
        print(f"Project root directory: {root_dir}")
        print(f"Python version: {sys.version}")
    
    # Parse .gitignore
    gitignore_path = os.path.join(root_dir, '.gitignore')
    gitignore_patterns = parse_gitignore(gitignore_path, verbose)
    
    if not gitignore_patterns:
        if verbose:
            print("No gitignore patterns found, using basic patterns")
        gitignore_patterns = ["*", "!*.py", "!*.json", "!*.md", "!*/"]
    
    # Find all files that should be included
    included_files = find_included_files(root_dir, gitignore_patterns, verbose)
    
    # Sort files for consistent output
    included_files.sort()
    
    if verbose:
        print(f"Found {len(included_files)} files to include in app.txt")
    
    # Output the list of files that will be included
    if verbose and included_files:
        print("Files to be included:")
        for file in included_files:
            rel_path = os.path.relpath(file, root_dir)
            print(f"  {rel_path}")
    
    # Create app.txt with all file contents
    output_path = os.path.join(root_dir, 'app.txt')
    create_app_txt(included_files, output_path, verbose)
    
    # Print summary
    if os.path.exists(output_path):
        file_size = os.path.getsize(output_path)
        print(f"Created {output_path}")
        print(f"Included {len(included_files)} files")
        print(f"Total size: {file_size / 1024:.2f} KB")
    else:
        print(f"Failed to create {output_path}")

if __name__ == "__main__":
    main()

================================================================================
FILE: tools\refactor_layout.py
================================================================================

# refactor_layout.py  (drop anywhere, run once)

import sys, re, shutil, datetime, textwrap
from pathlib import Path

# ------------------------- usage / path setup -------------------------
if len(sys.argv) != 2:
    print("Usage: python refactor_layout.py path/to/gui/ui/layout.py")
    sys.exit(1)

LAYOUT_PATH = Path(sys.argv[1]).expanduser().resolve()
if not LAYOUT_PATH.exists():
    sys.exit(f"[!] {LAYOUT_PATH} does not exist")

COMP_DIR = LAYOUT_PATH.parent / "components"
PROJECT_ROOT = LAYOUT_PATH.parents[3]  # only used for nice relative prints

# ------------------------- constants ----------------------------------
COMPONENT_ORDER = [
    "header_bar",
    "main_file_section",
    "presets_section",
    "column_controls_section",
    "reference_join_section",
    "config_export_section",
    "status_bar",
]

HEADER_TMPL = (
    '"""Autogenerated component extracted from layout.py."""\n\n'
    "import tkinter as tk\nfrom tkinter import ttk, messagebox\n\n"
    "from gui.ui.utils import *\n"
    "from gui.core.config_manager import load_config\n"
    "try:\n    from gui.ui.custom_widgets import FormulaEntry, TooltipButton, ProgressDialog\n"
    "except ImportError:\n    pass\n\n"
)

ORCH_TMPL = """\
\"\"\"Slim orchestrator, auto-generated.\"\"\"

from gui.ui.theme import apply_theme
from gui.ui import utils as U
from gui.ui.components import {imports}


def build_layout(app):
    if U.USE_ENHANCED_UI:
        app.theme = apply_theme(app.root)

    app.root.title("Matrix Exporter")
    app.root.geometry("1100x700")
    app.root.minsize(900, 600)

{calls}
    return app
"""

# ------------------------- helpers ------------------------------------
def snake(create_name: str) -> str:
    return create_name.replace("create_", "").rstrip("_")

def extract_functions(source: str):
    pattern = re.compile(
        r"^def (create_[A-Za-z0-9_]+)\s*\([^)]*\):\n"
        r"(?:    .*\n)+?", re.MULTILINE)
    out = {}
    for m in pattern.finditer(source):
        out[m.group(1)] = m.group(0)
    return out

# ------------------------- main logic ---------------------------------
def main():
    print(f"[*] Refactoring {LAYOUT_PATH.relative_to(PROJECT_ROOT)}")

    COMP_DIR.mkdir(parents=True, exist_ok=True)
    (COMP_DIR / "__init__.py").touch(exist_ok=True)

    raw_src = LAYOUT_PATH.read_text(encoding="utf-8")
    funcs = extract_functions(raw_src)

    for create_name, body in funcs.items():
        comp_name = snake(create_name)
        comp_path = COMP_DIR / f"{comp_name}.py"
        if comp_path.exists():
            print(f"  – {comp_name}.py exists, skipping")
            continue

        body_lines = body.splitlines()[1:]               # drop def line
        body_unind = "\n".join(l[4:] for l in body_lines)
        comp_code = HEADER_TMPL + "def build(app):\n" + textwrap.indent(body_unind, "    ")
        comp_path.write_text(comp_code, encoding="utf-8")
        print(f"  ✓ wrote {comp_path.relative_to(PROJECT_ROOT)}")

    # write new orchestrator
    imports = ", ".join(COMPONENT_ORDER)
    calls   = "\n".join(f"    {name}.build(app)" for name in COMPONENT_ORDER)
    new_layout = ORCH_TMPL.format(imports=imports, calls=calls)

    backup = LAYOUT_PATH.with_suffix(".bak_" + datetime.datetime.now().strftime("%Y%m%d_%H%M%S"))
    shutil.copy2(LAYOUT_PATH, backup)
    LAYOUT_PATH.write_text(new_layout, encoding="utf-8")
    print(f"  ↺ replaced layout.py (backup saved to {backup.name})")

    print("\n[OK] Layout split complete – run your GUI to verify.")

if __name__ == "__main__":
    main()


================================================================================
FILE: tools\split_utils.py
================================================================================

# tools/split_utils.py
import sys, textwrap, shutil, datetime
from pathlib import Path
import re

if len(sys.argv) != 2:
    sys.exit("Usage: python split_utils.py path/to/gui/ui/utils.py")

UTILS = Path(sys.argv[1]).expanduser().resolve()
ROOT  = UTILS.parents[2]            # project root for pretty prints
HELPERS_DIR = UTILS.parent / "helpers"
HELPERS_DIR.mkdir(exist_ok=True)
(HELPERS_DIR / "__init__.py").touch(exist_ok=True)

# -------------- extraction table (regex -> destination file) -------------
PATTERNS = {
    r"^# Color palette.*?(?=^def|\Z)":               "palette.py",
    r"^def create_tooltip.*?(?=^def|\Z)":            "tooltips.py",
    r"^def create_help_button.*?(?=^def|\Z)":        "tooltips.py",
    r"^def show_.*?message.*?(?=^def|\Z)":           "dialogs.py",
    r"^def create_status_bar.*?(?=^def|\Z)":         "statusbar.py",
    r"^def flash_.*?message.*?(?=^def|\Z)":          "statusbar.py",
    r"^def apply_modern_theme.*?(?=^def|\Z)":        "window.py",
    r"^def center_window.*?(?=^def|\Z)":             "window.py",
    r"^def save_app_settings.*?(?=^def|\Z)":         "file_utils.py",
    r"^def load_app_settings.*?(?=^def|\Z)":         "file_utils.py",
    r"^def create_backup_file.*?(?=^def|\Z)":        "file_utils.py",
    r"^PAD_X.*?FIELD_PAD.*":                         "palette.py",  # spacing consts
}

MODULE_SRC = {name: [] for name in set(PATTERNS.values())}

src = UTILS.read_text(encoding="utf-8")
for regex, fname in PATTERNS.items():
    for match in re.finditer(regex, src, re.M | re.S):
        MODULE_SRC[fname].append(match.group(0))
        src = src.replace(match.group(0), "")   # strip from main utils

# -------------- write helper modules --------------------------------------
HEADER = '"""Extracted from utils.py – generated by split_utils.py."""\n\n'

for fname, chunks in MODULE_SRC.items():
    if not chunks:
        continue
    code = HEADER + "\n\n".join(chunk.rstrip() for chunk in chunks) + "\n"
    (HELPERS_DIR / fname).write_text(code, encoding="utf-8")
    print(f" ✓ wrote helpers/{fname}")

# -------------- update utils.py -------------------------------------------
BACK = UTILS.with_suffix(".bak_" + datetime.datetime.now().strftime("%Y%m%d_%H%M%S"))
shutil.copy2(UTILS, BACK)
print(f"Backup saved → {BACK.relative_to(ROOT)}")

UTILS.write_text(
    '"""Facade that re-exports symbols from gui.ui.helpers.*"""\n\n'
    "from importlib import import_module as _imp\n"
    "__all__ = []\n"
    "for _mod in [\n"
    "    'palette', 'tooltips', 'dialogs', 'statusbar', 'window', 'file_utils']:\n"
    "    m = _imp(f'gui.ui.helpers.{_mod}')\n"
    "    globals().update({k:v for k,v in m.__dict__.items() if not k.startswith('_')})\n"
    "    __all__.extend([k for k in m.__dict__ if not k.startswith('_')])\n",
    encoding="utf-8",
)
print("Re-wrote utils.py as thin re-export façade")
print("\n[Done] Run your app and confirm all imports still resolve.")
